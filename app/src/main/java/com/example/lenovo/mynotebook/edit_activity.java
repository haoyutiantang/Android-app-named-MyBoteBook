package com.example.lenovo.mynotebook;import android.app.Activity;import android.content.ContentResolver;import android.content.Intent;import android.content.res.AssetManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Typeface;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.os.Message;import android.os.StrictMode;import android.provider.MediaStore;import android.support.v4.content.FileProvider;import android.text.Editable;import android.text.Spannable;import android.text.SpannableString;import android.text.style.ImageSpan;import android.util.Log;import android.view.KeyEvent;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.ScrollView;import android.widget.Toast;import com.example.lenovo.mynotebook.function.NoteWrapper;import com.example.lenovo.mynotebook.function.StringFunction;import com.example.lenovo.mynotebook.model.NoteInfo;import com.example.lenovo.mynotebook.ui.MessageBox;import com.example.lenovo.mynotebook.ui.UiHelper;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.Calendar;import java.util.Locale;public class edit_activity extends Activityimplements NoteWrapper.INoteInfo{    private ScrollView scrollView;    private EditText editText;    private Button gallery_btn;    private Button photo_btn;    private NoteInfo noteInfo;    private Intent intent;    private String originalContent=null;    private NoteWrapper noteWrapper;    public static final String IMAGEFilePATH="/sdcard/myImage/";    private String picpath;    private String content;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.edit_activity);     // getWindow().setBackgroundDrawableResource(R.drawable.timg);        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {            StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();            StrictMode.setVmPolicy(builder.build());        }        //通过自定义字体生成字体对象        AssetManager mgr=this.getAssets();        Typeface tf=Typeface.createFromAsset(mgr, "fonts/new.ttf");        scrollView=(ScrollView)findViewById(R.id.scrollView);        editText=(EditText)findViewById(R.id.content);        gallery_btn=(Button)findViewById(R.id.picture);        photo_btn=(Button)findViewById(R.id.photo);        editText.setTypeface(tf);        picpath=IMAGEFilePATH+ "temp.png";        /*        从相册获取图片         */        gallery_btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Intent getImage = new Intent(Intent.ACTION_GET_CONTENT);                getImage.addCategory(Intent.CATEGORY_OPENABLE);                getImage.setType("image/*");                startActivityForResult(getImage, 0x111);            }        });        /*        拍照获取图片        这里选择通过相机拍照，先将原图存到一个固定的picpath，然后传递Uri         */        photo_btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);                Uri uri = Uri.fromFile(new File(picpath));                intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);                startActivityForResult(intent, 0x222);            }        });        Bundle bundle = getIntent().getExtras();        noteWrapper=new NoteWrapper((NoteWrapper.INoteInfo) edit_activity.this,edit_activity.this);        //获取到NoteInfo对象，如果是null说明这是新建的笔记        noteInfo=(NoteInfo)bundle.getSerializable("flag");        if(noteInfo!=null) {            //获取图文内容            SpannableString ss=noteWrapper.getSpannedString(noteInfo.getContent(),                    edit_activity.this);            editText.setText(ss);            originalContent = noteInfo.getContent();        }    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        super.onActivityResult(requestCode, resultCode, data);        super.onActivityResult(requestCode, resultCode, intent);        ContentResolver resolver=getContentResolver();        /*        如果是从图库获取的图片         */        if(requestCode==0x111&&resultCode==RESULT_OK){            Uri originalUri=data.getData();            Bitmap ori_bitmap = null;            Bitmap ori_rbitmap = null;            //通过图库传来的Uri解析、压缩图片，防止            try {                ori_bitmap= BitmapFactory.decodeStream(resolver.openInputStream(originalUri),null,                        noteWrapper.getBili(480,800));                ori_bitmap=noteWrapper.jinyibu(ori_bitmap,edit_activity.this);            } catch (FileNotFoundException e) {                e.printStackTrace();            }            ori_rbitmap=ori_bitmap;            String sdStatus = Environment.getExternalStorageState();            if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) { // 检测sd是否可用                Log.i("TestFile","SD card is not avaiable/writeable right now.");            }            //将图片保存到新的文件并返回路路径            String myPath =noteWrapper.SaveToFile(IMAGEFilePATH,                    Calendar.getInstance(Locale.CHINA).getTimeInMillis() + ".jpg",                    ori_rbitmap);            //接下来这堆是处理将图片插入到EditText中的操作，我们知道这里写的比较糙            Log.w(myPath,"fileName");            SpannableString span_str = new SpannableString(myPath);            Bitmap my_bm=BitmapFactory.decodeFile(myPath);            Bitmap my_rbm=my_bm;            ImageSpan span = new ImageSpan(this, my_rbm);            span_str.setSpan(span, 0, myPath.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);            Editable et = editText.getText();// 先获取Edittext中的内容            int start = editText.getSelectionStart();            SpannableString newLine = new SpannableString("\n");            et.insert(start,newLine);            start = editText.getSelectionStart();            et.insert(start,newLine);            start = editText.getSelectionStart();            et.insert(start, span_str);// 设置ss要添加的位置            start = editText.getSelectionStart();            et.insert(start,newLine);            editText.setText((CharSequence)et);// 把et添加到Edittext中            editText.setSelection(start);// 设置Edittext中光标在最后面        }        /*        如果是从照相机获取的图片         */        if(requestCode==0x222&&resultCode==RESULT_OK){            String sdStatus = Environment.getExternalStorageState();            if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) { // 检测sd是否可用                Log.i("TestFile","SD card is not avaiable/writeable right now.");            }            String name = Calendar.getInstance(Locale.CHINA).getTimeInMillis() + ".jpg";//给拍的照片命名，下面进行存储            //这两句是用来将拍照获得的图片压缩防止OOM            Bitmap newb=BitmapFactory.decodeFile(picpath, noteWrapper.getBili(480,800));            Bitmap camera_rbitmap=noteWrapper.jinyibu(newb,edit_activity.this);            //将图片保存到新的文件并返回路路径            String myPath =noteWrapper.SaveToFile(IMAGEFilePATH,                    Calendar.getInstance(Locale.CHINA).getTimeInMillis() + ".jpg",                    camera_rbitmap);            //接下来这堆是处理将图片插入到EditText中的操作，我们知道这里写的比较糙            Log.w(myPath,"fileName");            SpannableString span_str = new SpannableString(myPath);            Bitmap my_bm=BitmapFactory.decodeFile(myPath);            Bitmap my_rbm=my_bm;            ImageSpan span = new ImageSpan(this, my_rbm);            span_str.setSpan(span, 0, myPath.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);            Editable et = editText.getText();// 先获取Edittext中的内容            int start = editText.getSelectionStart();            SpannableString newLine = new SpannableString("\n");            et.insert(start,newLine);            start = editText.getSelectionStart();            et.insert(start,newLine);            start = editText.getSelectionStart();            et.insert(start, span_str);// 设置ss要添加的位置            start = editText.getSelectionStart();            et.insert(start,newLine);            editText.setText((CharSequence)et);// 把et添加到Edittext中            editText.setSelection(start);// 设置Edittext中光标在最后面        }    }        /*        创建菜单         */    @Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    /*    菜单点击事件     */    @Override    public boolean onOptionsItemSelected(MenuItem item) {        switch (item.getItemId())        {            //菜单栏“保存”选项            case R.id.context_menu_save:                //获取最新编辑框的内容                 content=editText.getText().toString();                if(noteInfo==null&& StringFunction.isNotNullOrEmpty(content)) {//如果是新的笔记且内容不为空                  noteWrapper.SaveToDB(content, edit_activity.this,noteInfo);                    //originalContent=noteInfo.getContent();                }else if(noteInfo!=null&&//不是一个新的笔记                        !originalContent.equals(content)&&//与原文内容不一样                        StringFunction.isNotNullOrEmpty(content)){//内容不为空                  noteWrapper.SaveToDB(content, edit_activity.this,noteInfo);                }                originalContent=editText.getText().toString();                break;                //重命名选项            case R.id.context_menu_rename:                if(noteInfo==null){                    UiHelper.toastShowMessageShort(edit_activity.this,"此笔记未保存");                }else{                    noteWrapper.noteRename(edit_activity.this,noteInfo);                }                break;            //菜单栏“删除”选项            case   R.id.context_menu_delete:                 content=editText.getText().toString();                if(noteInfo==null||(checkByContent(content))){                    UiHelper.toastShowMessageShort(edit_activity.this,"笔记未保存，无法删除");                }else{                    noteWrapper.deleteNote(noteInfo,edit_activity.this);                }                break;                /*                分享功能，调用系统的分享模板，发送到任何可以接受的应用                 */            case R.id.context_menu_share:                content=editText.getText().toString();                if(noteInfo==null||(checkByContent(content))){                    UiHelper.toastShowMessageShort(edit_activity.this,"笔记未保存，无法分享");                }else {                    Bitmap bitmap = noteWrapper.compressImage(noteWrapper.getScrollViewBitmap(scrollView, null));                    File file = noteWrapper.bitMap2File(bitmap);                    if (file != null && file.exists() && file.isFile()) {                        //由文件得到uri                        Uri imageUri = Uri.fromFile(file);                        Intent shareIntent = new Intent();                        shareIntent.setAction(Intent.ACTION_SEND);                        shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);                        shareIntent.setType("image/*");                        startActivity(Intent.createChooser(shareIntent, "分享图片"));                    }                }                break;        }        return true;    }    @Override    public void getANewNote(NoteInfo noteInfos) {        this.noteInfo=noteInfos;    }    /*    监听返回键事件    如果笔记未保存,提醒用户    */    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        if(keyCode==KeyEvent.KEYCODE_BACK){           content=editText.getText().toString();            if(checkByContent(content)){                MessageBox messageBox=new MessageBox(edit_activity.this);                messageBox.showOKOrCancelDialog("此笔记未保存，是否返回", "提示",new MessageBox.IButtonClick() {                    @Override                    public void doSomething() {                        finish();                    }                },null);            }        }         return super.onKeyDown(keyCode, event);    }    /*    根据现在内容和原始内容来判断是否可以进行下一步操作     */        public boolean checkByContent(String content){            if((StringFunction.isNotNullOrEmpty(content)&&                    StringFunction.isNotNullOrEmpty(originalContent)&&                    !originalContent.equals(content))                    ||                    ( !StringFunction.isNotNullOrEmpty(originalContent)                            &&StringFunction.isNotNullOrEmpty(content))                    )                return true;            else return false;        }}